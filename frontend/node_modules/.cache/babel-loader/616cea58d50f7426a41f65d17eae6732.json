{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueryClient = void 0;\n/* eslint-disable no-dupe-class-members, @typescript-eslint/ban-types, @typescript-eslint/naming-convention */\n\nconst ics23_1 = require(\"@confio/ics23\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst stream_1 = require(\"@cosmjs/stream\");\n\nconst utils_1 = require(\"@cosmjs/utils\");\n\nfunction checkAndParseOp(op, kind, key) {\n  if (op.type !== kind) {\n    throw new Error(`Op expected to be ${kind}, got \"${op.type}`);\n  }\n\n  if (!utils_1.arrayContentEquals(key, op.key)) {\n    throw new Error(`Proven key different than queried key.\\nQuery: ${encoding_1.toHex(key)}\\nProven: ${encoding_1.toHex(op.key)}`);\n  }\n\n  return ics23_1.ics23.CommitmentProof.decode(op.data);\n}\n\nclass QueryClient {\n  constructor(tmClient) {\n    this.tmClient = tmClient;\n  }\n\n  static withExtensions(tmClient) {\n    const client = new QueryClient(tmClient);\n\n    for (var _len = arguments.length, extensionSetups = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      extensionSetups[_key - 1] = arguments[_key];\n    }\n\n    const extensions = extensionSetups.map(setupExtension => setupExtension(client));\n\n    for (const extension of extensions) {\n      utils_1.assert(utils_1.isNonNullObject(extension), `Extension must be a non-null object`);\n\n      for (const [moduleKey, moduleValue] of Object.entries(extension)) {\n        utils_1.assert(utils_1.isNonNullObject(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module \"${moduleKey}\".`);\n        const current = client[moduleKey] || {};\n        client[moduleKey] = Object.assign(Object.assign({}, current), moduleValue);\n      }\n    }\n\n    return client;\n  }\n\n  async queryVerified(store, key, desiredHeight) {\n    const {\n      height,\n      proof,\n      value\n    } = await this.queryRawProof(store, key, desiredHeight);\n    const subProof = checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n    const storeProof = checkAndParseOp(proof.ops[1], \"ics23:simple\", encoding_1.toAscii(store)); // this must always be existence, if the store is not a typo\n\n    utils_1.assert(storeProof.exist);\n    utils_1.assert(storeProof.exist.value); // this may be exist or non-exist, depends on response\n\n    if (!value || value.length === 0) {\n      // non-existence check\n      utils_1.assert(subProof.nonexist); // the subproof must map the desired key to the \"value\" of the storeProof\n\n      ics23_1.verifyNonExistence(subProof.nonexist, ics23_1.iavlSpec, storeProof.exist.value, key);\n    } else {\n      // existence check\n      utils_1.assert(subProof.exist);\n      utils_1.assert(subProof.exist.value); // the subproof must map the desired key to the \"value\" of the storeProof\n\n      ics23_1.verifyExistence(subProof.exist, ics23_1.iavlSpec, storeProof.exist.value, key, value);\n    } // the store proof must map its declared value (root of subProof) to the appHash of the next block\n\n\n    const header = await this.getNextHeader(height);\n    ics23_1.verifyExistence(storeProof.exist, ics23_1.tendermintSpec, header.appHash, encoding_1.toAscii(store), storeProof.exist.value);\n    return value;\n  }\n\n  async queryRawProof(store, queryKey, desiredHeight) {\n    var _a;\n\n    const {\n      key,\n      value,\n      height,\n      proof,\n      code,\n      log\n    } = await this.tmClient.abciQuery({\n      // we need the StoreKey for the module, not the module name\n      // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12\n      path: `/store/${store}/key`,\n      data: queryKey,\n      prove: true,\n      height: desiredHeight\n    });\n\n    if (code) {\n      throw new Error(`Query failed with (${code}): ${log}`);\n    }\n\n    if (!utils_1.arrayContentEquals(queryKey, key)) {\n      throw new Error(`Response key ${encoding_1.toHex(key)} doesn't match query key ${encoding_1.toHex(queryKey)}`);\n    }\n\n    if (!height) {\n      throw new Error(\"No query height returned\");\n    }\n\n    if (!proof || proof.ops.length !== 2) {\n      throw new Error(`Expected 2 proof ops, got ${(_a = proof === null || proof === void 0 ? void 0 : proof.ops.length) !== null && _a !== void 0 ? _a : 0}. Are you using stargate?`);\n    } // we don't need the results, but we can ensure the data is the proper format\n\n\n    checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n    checkAndParseOp(proof.ops[1], \"ics23:simple\", encoding_1.toAscii(store));\n    return {\n      key: key,\n      value: value,\n      height: height,\n      // need to clone this: readonly input / writeable output\n      proof: {\n        ops: [...proof.ops]\n      }\n    };\n  }\n\n  async queryUnverified(path, request) {\n    const response = await this.tmClient.abciQuery({\n      path: path,\n      data: request,\n      prove: false\n    });\n\n    if (response.code) {\n      throw new Error(`Query failed with (${response.code}): ${response.log}`);\n    }\n\n    return response.value;\n  } // this must return the header for height+1\n  // throws an error if height is 0 or undefined\n\n\n  async getNextHeader(height) {\n    utils_1.assertDefined(height);\n\n    if (height === 0) {\n      throw new Error(\"Query returned height 0, cannot prove it\");\n    }\n\n    const searchHeight = height + 1;\n    let nextHeader;\n    let headersSubscription;\n\n    try {\n      headersSubscription = this.tmClient.subscribeNewBlockHeader();\n    } catch (_a) {// Ignore exception caused by non-WebSocket Tendermint clients\n    }\n\n    if (headersSubscription) {\n      const firstHeader = await stream_1.firstEvent(headersSubscription); // The first header we get might not be n+1 but n+2 or even higher. In such cases we fall back on a query.\n\n      if (firstHeader.height === searchHeight) {\n        nextHeader = firstHeader;\n      }\n    }\n\n    while (!nextHeader) {\n      // start from current height to avoid backend error for minHeight in the future\n      const correctHeader = (await this.tmClient.blockchain(height, searchHeight)).blockMetas.map(meta => meta.header).find(h => h.height === searchHeight);\n\n      if (correctHeader) {\n        nextHeader = correctHeader;\n      } else {\n        await utils_1.sleep(1000);\n      }\n    }\n\n    utils_1.assert(nextHeader.height === searchHeight, \"Got wrong header. This is a bug in the logic above.\");\n    return nextHeader;\n  }\n\n}\n\nexports.QueryClient = QueryClient;","map":{"version":3,"mappings":"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","names":["checkAndParseOp","op","kind","key","type","Error","utils_1","encoding_1","ics23_1","CommitmentProof","decode","data","QueryClient","constructor","tmClient","withExtensions","client","extensionSetups","extensions","map","setupExtension","extension","moduleKey","moduleValue","Object","entries","current","queryVerified","store","desiredHeight","height","proof","value","queryRawProof","subProof","ops","storeProof","exist","length","nonexist","header","getNextHeader","appHash","queryKey","code","log","abciQuery","path","prove","_a","queryUnverified","request","response","searchHeight","nextHeader","headersSubscription","subscribeNewBlockHeader","firstHeader","stream_1","correctHeader","blockchain","blockMetas","meta","find","h","exports"],"sourceRoot":"","sources":["../../src/queries/queryclient.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}