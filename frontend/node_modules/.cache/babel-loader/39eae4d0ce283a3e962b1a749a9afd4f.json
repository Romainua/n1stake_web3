{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DirectSecp256k1HdWallet = exports.extractKdfConfiguration = void 0;\n\nconst amino_1 = require(\"@cosmjs/amino\");\n\nconst crypto_1 = require(\"@cosmjs/crypto\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst build_1 = require(\"@cosmjs/utils/build\");\n\nconst signing_1 = require(\"./signing\");\n\nconst wallet_1 = require(\"./wallet\");\n\nconst serializationTypeV1 = \"directsecp256k1hdwallet-v1\";\n/**\n * A KDF configuration that is not very strong but can be used on the main thread.\n * It takes about 1 second in Node.js 16.0.0 and should have similar runtimes in other modern Wasm hosts.\n */\n\nconst basicPasswordHashingOptions = {\n  algorithm: \"argon2id\",\n  params: {\n    outputLength: 32,\n    opsLimit: 24,\n    memLimitKib: 12 * 1024\n  }\n};\n\nfunction isDerivationJson(thing) {\n  if (!build_1.isNonNullObject(thing)) return false;\n  if (typeof thing.hdPath !== \"string\") return false;\n  if (typeof thing.prefix !== \"string\") return false;\n  return true;\n}\n\nfunction extractKdfConfigurationV1(doc) {\n  return doc.kdf;\n}\n\nfunction extractKdfConfiguration(serialization) {\n  const root = JSON.parse(serialization);\n  if (!build_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n\n  switch (root.type) {\n    case serializationTypeV1:\n      return extractKdfConfigurationV1(root);\n\n    default:\n      throw new Error(\"Unsupported serialization type\");\n  }\n}\n\nexports.extractKdfConfiguration = extractKdfConfiguration;\nconst defaultOptions = {\n  bip39Password: \"\",\n  hdPaths: [amino_1.makeCosmoshubPath(0)],\n  prefix: \"cosmos\"\n};\n/** A wallet for protobuf based signing using SIGN_MODE_DIRECT */\n\nclass DirectSecp256k1HdWallet {\n  constructor(mnemonic, options) {\n    var _a, _b;\n\n    const prefix = (_a = options.prefix) !== null && _a !== void 0 ? _a : defaultOptions.prefix;\n    const hdPaths = (_b = options.hdPaths) !== null && _b !== void 0 ? _b : defaultOptions.hdPaths;\n    this.secret = mnemonic;\n    this.seed = options.seed;\n    this.accounts = hdPaths.map(hdPath => ({\n      hdPath: hdPath,\n      prefix: prefix\n    }));\n  }\n  /**\n   * Restores a wallet from the given BIP39 mnemonic.\n   *\n   * @param mnemonic Any valid English mnemonic.\n   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n\n\n  static async fromMnemonic(mnemonic) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);\n    const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);\n    return new DirectSecp256k1HdWallet(mnemonicChecked, Object.assign(Object.assign({}, options), {\n      seed: seed\n    }));\n  }\n  /**\n   * Generates a new wallet with a BIP39 mnemonic of the given length.\n   *\n   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).\n   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n\n\n  static async generate() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const entropyLength = 4 * Math.floor(11 * length / 33);\n    const entropy = crypto_1.Random.getBytes(entropyLength);\n    const mnemonic = crypto_1.Bip39.encode(entropy);\n    return DirectSecp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n\n\n  static async deserialize(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!build_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n\n    switch (root.type) {\n      case serializationTypeV1:\n        return DirectSecp256k1HdWallet.deserializeTypeV1(serialization, password);\n\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows\n   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be\n   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.\n   */\n\n\n  static async deserializeWithEncryptionKey(serialization, encryptionKey) {\n    const root = JSON.parse(serialization);\n    if (!build_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n    const untypedRoot = root;\n\n    switch (untypedRoot.type) {\n      case serializationTypeV1:\n        {\n          const decryptedBytes = await wallet_1.decrypt(encoding_1.fromBase64(untypedRoot.data), encryptionKey, untypedRoot.encryption);\n          const decryptedDocument = JSON.parse(encoding_1.fromUtf8(decryptedBytes));\n          const {\n            mnemonic,\n            accounts\n          } = decryptedDocument;\n          build_1.assert(typeof mnemonic === \"string\");\n          if (!Array.isArray(accounts)) throw new Error(\"Property 'accounts' is not an array\");\n\n          if (!accounts.every(account => isDerivationJson(account))) {\n            throw new Error(\"Account is not in the correct format.\");\n          }\n\n          const firstPrefix = accounts[0].prefix;\n\n          if (!accounts.every(_ref => {\n            let {\n              prefix\n            } = _ref;\n            return prefix === firstPrefix;\n          })) {\n            throw new Error(\"Accounts do not all have the same prefix\");\n          }\n\n          const hdPaths = accounts.map(_ref2 => {\n            let {\n              hdPath\n            } = _ref2;\n            return crypto_1.stringToPath(hdPath);\n          });\n          return DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {\n            hdPaths: hdPaths,\n            prefix: firstPrefix\n          });\n        }\n\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n\n  static async deserializeTypeV1(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!build_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n    const encryptionKey = await wallet_1.executeKdf(password, root.kdf);\n    return DirectSecp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);\n  }\n\n  get mnemonic() {\n    return this.secret.toString();\n  }\n\n  async getAccounts() {\n    const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();\n    return accountsWithPrivkeys.map(_ref3 => {\n      let {\n        algo,\n        pubkey,\n        address\n      } = _ref3;\n      return {\n        algo: algo,\n        pubkey: pubkey,\n        address: address\n      };\n    });\n  }\n\n  async signDirect(signerAddress, signDoc) {\n    const accounts = await this.getAccountsWithPrivkeys();\n    const account = accounts.find(_ref4 => {\n      let {\n        address\n      } = _ref4;\n      return address === signerAddress;\n    });\n\n    if (account === undefined) {\n      throw new Error(`Address ${signerAddress} not found in wallet`);\n    }\n\n    const {\n      privkey,\n      pubkey\n    } = account;\n    const signBytes = signing_1.makeSignBytes(signDoc);\n    const hashedMessage = crypto_1.sha256(signBytes);\n    const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, privkey);\n    const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);\n    const stdSignature = amino_1.encodeSecp256k1Signature(pubkey, signatureBytes);\n    return {\n      signed: signDoc,\n      signature: stdSignature\n    };\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n\n\n  async serialize(password) {\n    const kdfConfiguration = basicPasswordHashingOptions;\n    const encryptionKey = await wallet_1.executeKdf(password, kdfConfiguration);\n    return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to\n   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF options. If this\n   * is not the case, the wallet cannot be restored with the original password.\n   */\n\n\n  async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {\n    const dataToEncrypt = {\n      mnemonic: this.mnemonic,\n      accounts: this.accounts.map(_ref5 => {\n        let {\n          hdPath,\n          prefix\n        } = _ref5;\n        return {\n          hdPath: crypto_1.pathToString(hdPath),\n          prefix: prefix\n        };\n      })\n    };\n    const dataToEncryptRaw = encoding_1.toUtf8(JSON.stringify(dataToEncrypt));\n    const encryptionConfiguration = {\n      algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf\n    };\n    const encryptedData = await wallet_1.encrypt(dataToEncryptRaw, encryptionKey, encryptionConfiguration);\n    const out = {\n      type: serializationTypeV1,\n      kdf: kdfConfiguration,\n      encryption: encryptionConfiguration,\n      data: encoding_1.toBase64(encryptedData)\n    };\n    return JSON.stringify(out);\n  }\n\n  async getKeyPair(hdPath) {\n    const {\n      privkey\n    } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);\n    const {\n      pubkey\n    } = await crypto_1.Secp256k1.makeKeypair(privkey);\n    return {\n      privkey: privkey,\n      pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)\n    };\n  }\n\n  async getAccountsWithPrivkeys() {\n    return Promise.all(this.accounts.map(async _ref6 => {\n      let {\n        hdPath,\n        prefix\n      } = _ref6;\n      const {\n        privkey,\n        pubkey\n      } = await this.getKeyPair(hdPath);\n      const address = encoding_1.Bech32.encode(prefix, amino_1.rawSecp256k1PubkeyToRawAddress(pubkey));\n      return {\n        algo: \"secp256k1\",\n        privkey: privkey,\n        pubkey: pubkey,\n        address: address\n      };\n    }));\n  }\n\n}\n\nexports.DirectSecp256k1HdWallet = DirectSecp256k1HdWallet;","map":{"version":3,"mappings":"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","names":["serializationTypeV1","basicPasswordHashingOptions","algorithm","params","outputLength","opsLimit","memLimitKib","isDerivationJson","thing","build_1","hdPath","prefix","extractKdfConfigurationV1","doc","kdf","extractKdfConfiguration","serialization","root","JSON","parse","Error","type","exports","defaultOptions","bip39Password","hdPaths","amino_1","DirectSecp256k1HdWallet","constructor","mnemonic","options","_a","_b","secret","seed","accounts","map","fromMnemonic","mnemonicChecked","crypto_1","mnemonicToSeed","Object","generate","length","entropyLength","Math","floor","entropy","getBytes","encode","toString","deserialize","password","deserializeTypeV1","deserializeWithEncryptionKey","encryptionKey","untypedRoot","decryptedBytes","wallet_1","encoding_1","data","encryption","decryptedDocument","Array","isArray","every","account","firstPrefix","getAccounts","accountsWithPrivkeys","getAccountsWithPrivkeys","algo","pubkey","address","signDirect","signerAddress","signDoc","find","undefined","privkey","signBytes","signing_1","hashedMessage","signature","createSignature","signatureBytes","Uint8Array","r","s","stdSignature","signed","serialize","kdfConfiguration","serializeWithEncryptionKey","dataToEncrypt","dataToEncryptRaw","stringify","encryptionConfiguration","xchacha20poly1305Ietf","encryptedData","out","getKeyPair","derivePath","Secp256k1","makeKeypair","compressPubkey","Promise","all"],"sourceRoot":"","sources":["../src/directsecp256k1hdwallet.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}