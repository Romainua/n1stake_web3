{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Secp256k1HdWallet = exports.extractKdfConfiguration = void 0;\n\nconst crypto_1 = require(\"@cosmjs/crypto\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst utils_1 = require(\"@cosmjs/utils\");\n\nconst addresses_1 = require(\"./addresses\");\n\nconst paths_1 = require(\"./paths\");\n\nconst signature_1 = require(\"./signature\");\n\nconst signdoc_1 = require(\"./signdoc\");\n\nconst wallet_1 = require(\"./wallet\");\n\nconst serializationTypeV1 = \"secp256k1wallet-v1\";\n/**\n * A KDF configuration that is not very strong but can be used on the main thread.\n * It takes about 1 second in Node.js 16.0.0 and should have similar runtimes in other modern Wasm hosts.\n */\n\nconst basicPasswordHashingOptions = {\n  algorithm: \"argon2id\",\n  params: {\n    outputLength: 32,\n    opsLimit: 24,\n    memLimitKib: 12 * 1024\n  }\n};\n\nfunction isDerivationJson(thing) {\n  if (!utils_1.isNonNullObject(thing)) return false;\n  if (typeof thing.hdPath !== \"string\") return false;\n  if (typeof thing.prefix !== \"string\") return false;\n  return true;\n}\n\nfunction extractKdfConfigurationV1(doc) {\n  return doc.kdf;\n}\n\nfunction extractKdfConfiguration(serialization) {\n  const root = JSON.parse(serialization);\n  if (!utils_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n\n  switch (root.type) {\n    case serializationTypeV1:\n      return extractKdfConfigurationV1(root);\n\n    default:\n      throw new Error(\"Unsupported serialization type\");\n  }\n}\n\nexports.extractKdfConfiguration = extractKdfConfiguration;\nconst defaultOptions = {\n  bip39Password: \"\",\n  hdPaths: [paths_1.makeCosmoshubPath(0)],\n  prefix: \"cosmos\"\n};\n\nclass Secp256k1HdWallet {\n  constructor(mnemonic, options) {\n    var _a, _b;\n\n    const hdPaths = (_a = options.hdPaths) !== null && _a !== void 0 ? _a : defaultOptions.hdPaths;\n    const prefix = (_b = options.prefix) !== null && _b !== void 0 ? _b : defaultOptions.prefix;\n    this.secret = mnemonic;\n    this.seed = options.seed;\n    this.accounts = hdPaths.map(hdPath => ({\n      hdPath: hdPath,\n      prefix\n    }));\n  }\n  /**\n   * Restores a wallet from the given BIP39 mnemonic.\n   *\n   * @param mnemonic Any valid English mnemonic.\n   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n\n\n  static async fromMnemonic(mnemonic) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);\n    const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);\n    return new Secp256k1HdWallet(mnemonicChecked, Object.assign(Object.assign({}, options), {\n      seed: seed\n    }));\n  }\n  /**\n   * Generates a new wallet with a BIP39 mnemonic of the given length.\n   *\n   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).\n   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n\n\n  static async generate() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const entropyLength = 4 * Math.floor(11 * length / 33);\n    const entropy = crypto_1.Random.getBytes(entropyLength);\n    const mnemonic = crypto_1.Bip39.encode(entropy);\n    return Secp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n\n\n  static async deserialize(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!utils_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n\n    switch (root.type) {\n      case serializationTypeV1:\n        return Secp256k1HdWallet.deserializeTypeV1(serialization, password);\n\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows\n   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be\n   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.\n   */\n\n\n  static async deserializeWithEncryptionKey(serialization, encryptionKey) {\n    const root = JSON.parse(serialization);\n    if (!utils_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n    const untypedRoot = root;\n\n    switch (untypedRoot.type) {\n      case serializationTypeV1:\n        {\n          const decryptedBytes = await wallet_1.decrypt(encoding_1.fromBase64(untypedRoot.data), encryptionKey, untypedRoot.encryption);\n          const decryptedDocument = JSON.parse(encoding_1.fromUtf8(decryptedBytes));\n          const {\n            mnemonic,\n            accounts\n          } = decryptedDocument;\n          utils_1.assert(typeof mnemonic === \"string\");\n          if (!Array.isArray(accounts)) throw new Error(\"Property 'accounts' is not an array\");\n\n          if (!accounts.every(account => isDerivationJson(account))) {\n            throw new Error(\"Account is not in the correct format.\");\n          }\n\n          const firstPrefix = accounts[0].prefix;\n\n          if (!accounts.every(_ref => {\n            let {\n              prefix\n            } = _ref;\n            return prefix === firstPrefix;\n          })) {\n            throw new Error(\"Accounts do not all have the same prefix\");\n          }\n\n          const hdPaths = accounts.map(_ref2 => {\n            let {\n              hdPath\n            } = _ref2;\n            return crypto_1.stringToPath(hdPath);\n          });\n          return Secp256k1HdWallet.fromMnemonic(mnemonic, {\n            hdPaths: hdPaths,\n            prefix: firstPrefix\n          });\n        }\n\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n\n  static async deserializeTypeV1(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!utils_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n    const encryptionKey = await wallet_1.executeKdf(password, root.kdf);\n    return Secp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);\n  }\n\n  get mnemonic() {\n    return this.secret.toString();\n  }\n\n  async getAccounts() {\n    const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();\n    return accountsWithPrivkeys.map(_ref3 => {\n      let {\n        algo,\n        pubkey,\n        address\n      } = _ref3;\n      return {\n        algo: algo,\n        pubkey: pubkey,\n        address: address\n      };\n    });\n  }\n\n  async signAmino(signerAddress, signDoc) {\n    const accounts = await this.getAccountsWithPrivkeys();\n    const account = accounts.find(_ref4 => {\n      let {\n        address\n      } = _ref4;\n      return address === signerAddress;\n    });\n\n    if (account === undefined) {\n      throw new Error(`Address ${signerAddress} not found in wallet`);\n    }\n\n    const {\n      privkey,\n      pubkey\n    } = account;\n    const message = crypto_1.sha256(signdoc_1.serializeSignDoc(signDoc));\n    const signature = await crypto_1.Secp256k1.createSignature(message, privkey);\n    const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);\n    return {\n      signed: signDoc,\n      signature: signature_1.encodeSecp256k1Signature(pubkey, signatureBytes)\n    };\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n\n\n  async serialize(password) {\n    const kdfConfiguration = basicPasswordHashingOptions;\n    const encryptionKey = await wallet_1.executeKdf(password, kdfConfiguration);\n    return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to\n   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF options. If this\n   * is not the case, the wallet cannot be restored with the original password.\n   */\n\n\n  async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {\n    const dataToEncrypt = {\n      mnemonic: this.mnemonic,\n      accounts: this.accounts.map(_ref5 => {\n        let {\n          hdPath,\n          prefix\n        } = _ref5;\n        return {\n          hdPath: crypto_1.pathToString(hdPath),\n          prefix: prefix\n        };\n      })\n    };\n    const dataToEncryptRaw = encoding_1.toUtf8(JSON.stringify(dataToEncrypt));\n    const encryptionConfiguration = {\n      algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf\n    };\n    const encryptedData = await wallet_1.encrypt(dataToEncryptRaw, encryptionKey, encryptionConfiguration);\n    const out = {\n      type: serializationTypeV1,\n      kdf: kdfConfiguration,\n      encryption: encryptionConfiguration,\n      data: encoding_1.toBase64(encryptedData)\n    };\n    return JSON.stringify(out);\n  }\n\n  async getKeyPair(hdPath) {\n    const {\n      privkey\n    } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);\n    const {\n      pubkey\n    } = await crypto_1.Secp256k1.makeKeypair(privkey);\n    return {\n      privkey: privkey,\n      pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)\n    };\n  }\n\n  async getAccountsWithPrivkeys() {\n    return Promise.all(this.accounts.map(async _ref6 => {\n      let {\n        hdPath,\n        prefix\n      } = _ref6;\n      const {\n        privkey,\n        pubkey\n      } = await this.getKeyPair(hdPath);\n      const address = encoding_1.Bech32.encode(prefix, addresses_1.rawSecp256k1PubkeyToRawAddress(pubkey));\n      return {\n        algo: \"secp256k1\",\n        privkey: privkey,\n        pubkey: pubkey,\n        address: address\n      };\n    }));\n  }\n\n}\n\nexports.Secp256k1HdWallet = Secp256k1HdWallet;","map":{"version":3,"mappings":"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","names":["serializationTypeV1","basicPasswordHashingOptions","algorithm","params","outputLength","opsLimit","memLimitKib","isDerivationJson","thing","utils_1","hdPath","prefix","extractKdfConfigurationV1","doc","kdf","extractKdfConfiguration","serialization","root","JSON","parse","Error","type","exports","defaultOptions","bip39Password","hdPaths","paths_1","Secp256k1HdWallet","constructor","mnemonic","options","_a","_b","secret","seed","accounts","map","fromMnemonic","mnemonicChecked","crypto_1","mnemonicToSeed","Object","generate","length","entropyLength","Math","floor","entropy","getBytes","encode","toString","deserialize","password","deserializeTypeV1","deserializeWithEncryptionKey","encryptionKey","untypedRoot","decryptedBytes","wallet_1","encoding_1","data","encryption","decryptedDocument","Array","isArray","every","account","firstPrefix","getAccounts","accountsWithPrivkeys","getAccountsWithPrivkeys","algo","pubkey","address","signAmino","signerAddress","signDoc","find","undefined","privkey","message","signdoc_1","signature","createSignature","signatureBytes","Uint8Array","r","s","signed","signature_1","serialize","kdfConfiguration","serializeWithEncryptionKey","dataToEncrypt","dataToEncryptRaw","stringify","encryptionConfiguration","xchacha20poly1305Ietf","encryptedData","out","getKeyPair","derivePath","Secp256k1","makeKeypair","compressPubkey","Promise","all","addresses_1"],"sourceRoot":"","sources":["../src/secp256k1hdwallet.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}